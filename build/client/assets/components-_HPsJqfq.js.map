{"version":3,"mappings":"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","names":["_extends","target","i","source","key","invariant","value","message","loadRouteModule","route","routeModulesCache","routeModule","__vitePreload","getKeyedLinksForMatches","matches","routeModules","manifest","descriptors","match","_module$links","module","href","preloads","getCurrentPageModulePreloadHrefs","dedupeLinkDescriptors","prefetchStyleLinks","_route$css","_routeModule$links","isPreloadSupported","styleLinks","descriptor","isPageLinkDescriptor","matchingLinks","link","prefetchStyleLink","resolve","removeLink","object","isHtmlLinkDescriptor","getKeyedPrefetchLinks","links","mod","getNewMatchesForLinks","page","nextMatches","currentMatches","location","mode","path","parsePathPatch","isNew","index","matchPathChanged","_currentMatches$index","_currentMatches$","routeChoice","manifestRoute","getDataLinkHrefs","dedupeHrefs","pathname","search","searchParams","getModuleLinkHrefs","manifestPatch","hrefs","sortKeys","obj","sorted","keys","set","preloadsSet","deduped","parsePath","_isPreloadSupported","el","ESCAPE_LOOKUP","ESCAPE_REGEX","escapeHtml","html","createHtml","useDataRouterContext","context","React.useContext","UNSAFE_DataRouterContext","useDataRouterStateContext","UNSAFE_DataRouterStateContext","RemixContext","React.createContext","useRemixContext","usePrefetchBehavior","prefetch","theirElementProps","maybePrefetch","setMaybePrefetch","React.useState","shouldPrefetch","setShouldPrefetch","onFocus","onBlur","onMouseEnter","onMouseLeave","onTouchStart","ref","React.useRef","React.useEffect","callback","entries","entry","observer","setIntent","cancelIntent","id","composeEventHandlers","ABSOLUTE_URL_REGEX","NavLink","React.forwardRef","to","props","forwardedRef","isAbsolute","useHref","prefetchHandlers","React.createElement","React.Fragment","NavLink$1","mergeRefs","PrefetchPageLinks","Link","Link$1","theirHandler","ourHandler","event","getActiveMatches","errors","isSpaMode","isHydrated","errorIdx","m","Links","criticalCss","routerMatches","keyedLinks","React.useMemo","dataLinkProps","router","matchRoutes","PrefetchPageLinksImpl","useKeyedPrefetchLinks","keyedPrefetchLinks","setKeyedPrefetchLinks","interrupted","linkProps","useLocation","newMatchesForData","newMatchesForAssets","dataHrefs","moduleHrefs","Meta","loaderData","_matches","error","meta","leafMeta","_match","routeId","data","params","routeMeta","metaProps","tagName","rest","isValidMetaTag","Comp","json","Await","Await$1","Scripts","serverHandoffString","abortDelay","serializeError","isStatic","staticContext","navigation","useNavigation","serializePreResolvedErrorImp","toSerialize","serializePreresolvedDataImp","serializedData","serializeErrorImp","serializeDataImp","deferredScripts","initialScripts","_manifest$hmr","contextScript","activeDeferreds","deferredData","pendingKeys","promiseKeyValues","DeferredHydrationScript","trackedPromise","routeModulesScript","routePreloads","dedupe","dataKey","scriptProps","serializeData","React.Suspense","ErrorDeferredHydrationScript","useAsyncError","array","useMatches","useMatches$1","useLoaderData","useLoaderData$1","useRouteLoaderData","useRouteLoaderData$1","useActionData","useActionData$1","useFetcher","opts","useFetcher$1","refs"],"sources":["../../../node_modules/@remix-run/react/dist/esm/_virtual/_rollupPluginBabelHelpers.js","../../../node_modules/@remix-run/react/dist/esm/invariant.js","../../../node_modules/@remix-run/react/dist/esm/routeModules.js","../../../node_modules/@remix-run/react/dist/esm/links.js","../../../node_modules/@remix-run/react/dist/esm/markup.js","../../../node_modules/@remix-run/react/dist/esm/components.js"],"sourcesContent":["/**\n * @remix-run/react v2.8.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\nexport { _extends as extends };\n","/**\n * @remix-run/react v2.8.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\n\nexport { invariant as default };\n","/**\n * @remix-run/react v2.8.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n/**\n * A function that handles data mutations for a route on the client\n */\n\n/**\n * Arguments passed to a route `clientAction` function\n */\n\n/**\n * A function that loads data for a route on the client\n */\n\n/**\n * Arguments passed to a route `clientLoader` function\n */\n\n/**\n * ErrorBoundary to display for this route\n */\n\n/**\n * `<Route HydrateFallback>` component to render on initial loads\n * when client loaders are present\n */\n\n/**\n * Optional, root-only `<Route Layout>` component to wrap the root content in.\n * Useful for defining the <html>/<head>/<body> document shell shared by the\n * Component, HydrateFallback, and ErrorBoundary\n */\n\n/**\n * A function that defines `<link>` tags to be inserted into the `<head>` of\n * the document on route transitions.\n *\n * @see https://remix.run/route/meta\n */\n\n/**\n * A React component that is rendered for a route.\n */\n\n/**\n * An arbitrary object that is associated with a route.\n *\n * @see https://remix.run/route/handle\n */\n\nasync function loadRouteModule(route, routeModulesCache) {\n  if (route.id in routeModulesCache) {\n    return routeModulesCache[route.id];\n  }\n  try {\n    let routeModule = await import( /* webpackIgnore: true */route.module);\n    routeModulesCache[route.id] = routeModule;\n    return routeModule;\n  } catch (error) {\n    // User got caught in the middle of a deploy and the CDN no longer has the\n    // asset we're trying to import! Reload from the server and the user\n    // (should) get the new manifest--unless the developer purged the static\n    // assets, the manifest path, but not the documents 😬\n    if (window.__remixContext.isSpaMode &&\n    // @ts-expect-error\n    typeof import.meta.hot !== \"undefined\") {\n      // In SPA Mode (which implies vite) we don't want to perform a hard reload\n      // on dev-time errors since it's a vite compilation error and a reload is\n      // just going to fail with the same issue.  Let the UI bubble to the error\n      // boundary and let them see the error in the overlay or the dev server log\n      console.error(`Error loading route module \\`${route.module}\\`:`, error);\n      throw error;\n    }\n    window.location.reload();\n    return new Promise(() => {\n      // check out of this hook cause the DJs never gonna re[s]olve this\n    });\n  }\n}\n\nexport { loadRouteModule };\n","/**\n * @remix-run/react v2.8.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { parsePath } from 'react-router-dom';\nimport { loadRouteModule } from './routeModules.js';\n\n/**\n * Represents a `<link>` element.\n *\n * WHATWG Specification: https://html.spec.whatwg.org/multipage/semantics.html#the-link-element\n */\n\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * Gets all the links for a set of matches. The modules are assumed to have been\n * loaded already.\n */\nfunction getKeyedLinksForMatches(matches, routeModules, manifest) {\n  let descriptors = matches.map(match => {\n    var _module$links;\n    let module = routeModules[match.route.id];\n    let route = manifest.routes[match.route.id];\n    return [route.css ? route.css.map(href => ({\n      rel: \"stylesheet\",\n      href\n    })) : [], (module === null || module === void 0 ? void 0 : (_module$links = module.links) === null || _module$links === void 0 ? void 0 : _module$links.call(module)) || []];\n  }).flat(2);\n  let preloads = getCurrentPageModulePreloadHrefs(matches, manifest);\n  return dedupeLinkDescriptors(descriptors, preloads);\n}\nasync function prefetchStyleLinks(route, routeModule) {\n  var _route$css, _routeModule$links;\n  if (!route.css && !routeModule.links || !isPreloadSupported()) return;\n  let descriptors = [((_route$css = route.css) === null || _route$css === void 0 ? void 0 : _route$css.map(href => ({\n    rel: \"stylesheet\",\n    href\n  }))) ?? [], ((_routeModule$links = routeModule.links) === null || _routeModule$links === void 0 ? void 0 : _routeModule$links.call(routeModule)) ?? []].flat(1);\n  if (descriptors.length === 0) return;\n  let styleLinks = [];\n  for (let descriptor of descriptors) {\n    if (!isPageLinkDescriptor(descriptor) && descriptor.rel === \"stylesheet\") {\n      styleLinks.push({\n        ...descriptor,\n        rel: \"preload\",\n        as: \"style\"\n      });\n    }\n  }\n\n  // don't block for non-matching media queries, or for stylesheets that are\n  // already in the DOM (active route revalidations)\n  let matchingLinks = styleLinks.filter(link => (!link.media || window.matchMedia(link.media).matches) && !document.querySelector(`link[rel=\"stylesheet\"][href=\"${link.href}\"]`));\n  await Promise.all(matchingLinks.map(prefetchStyleLink));\n}\nasync function prefetchStyleLink(descriptor) {\n  return new Promise(resolve => {\n    let link = document.createElement(\"link\");\n    Object.assign(link, descriptor);\n    function removeLink() {\n      // if a navigation interrupts this prefetch React will update the <head>\n      // and remove the link we put in there manually, so we check if it's still\n      // there before trying to remove it\n      if (document.head.contains(link)) {\n        document.head.removeChild(link);\n      }\n    }\n    link.onload = () => {\n      removeLink();\n      resolve();\n    };\n    link.onerror = () => {\n      removeLink();\n      resolve();\n    };\n    document.head.appendChild(link);\n  });\n}\n\n////////////////////////////////////////////////////////////////////////////////\nfunction isPageLinkDescriptor(object) {\n  return object != null && typeof object.page === \"string\";\n}\nfunction isHtmlLinkDescriptor(object) {\n  if (object == null) {\n    return false;\n  }\n\n  // <link> may not have an href if <link rel=\"preload\"> is used with imageSrcSet + imageSizes\n  // https://github.com/remix-run/remix/issues/184\n  // https://html.spec.whatwg.org/commit-snapshots/cb4f5ff75de5f4cbd7013c4abad02f21c77d4d1c/#attr-link-imagesrcset\n  if (object.href == null) {\n    return object.rel === \"preload\" && typeof object.imageSrcSet === \"string\" && typeof object.imageSizes === \"string\";\n  }\n  return typeof object.rel === \"string\" && typeof object.href === \"string\";\n}\nasync function getKeyedPrefetchLinks(matches, manifest, routeModules) {\n  let links = await Promise.all(matches.map(async match => {\n    let mod = await loadRouteModule(manifest.routes[match.route.id], routeModules);\n    return mod.links ? mod.links() : [];\n  }));\n  return dedupeLinkDescriptors(links.flat(1).filter(isHtmlLinkDescriptor).filter(link => link.rel === \"stylesheet\" || link.rel === \"preload\").map(link => link.rel === \"stylesheet\" ? {\n    ...link,\n    rel: \"prefetch\",\n    as: \"style\"\n  } : {\n    ...link,\n    rel: \"prefetch\"\n  }));\n}\n\n// This is ridiculously identical to transition.ts `filterMatchesToLoad`\nfunction getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {\n  let path = parsePathPatch(page);\n  let isNew = (match, index) => {\n    if (!currentMatches[index]) return true;\n    return match.route.id !== currentMatches[index].route.id;\n  };\n  let matchPathChanged = (match, index) => {\n    var _currentMatches$index;\n    return (\n      // param change, /users/123 -> /users/456\n      currentMatches[index].pathname !== match.pathname ||\n      // splat param changed, which is not present in match.path\n      // e.g. /files/images/avatar.jpg -> files/finances.xls\n      ((_currentMatches$index = currentMatches[index].route.path) === null || _currentMatches$index === void 0 ? void 0 : _currentMatches$index.endsWith(\"*\")) && currentMatches[index].params[\"*\"] !== match.params[\"*\"]\n    );\n  };\n\n  // NOTE: keep this mostly up-to-date w/ the transition data diff, but this\n  // version doesn't care about submissions\n  let newMatches = mode === \"data\" && location.search !== path.search ?\n  // this is really similar to stuff in transition.ts, maybe somebody smarter\n  // than me (or in less of a hurry) can share some of it. You're the best.\n  nextMatches.filter((match, index) => {\n    let manifestRoute = manifest.routes[match.route.id];\n    if (!manifestRoute.hasLoader) {\n      return false;\n    }\n    if (isNew(match, index) || matchPathChanged(match, index)) {\n      return true;\n    }\n    if (match.route.shouldRevalidate) {\n      var _currentMatches$;\n      let routeChoice = match.route.shouldRevalidate({\n        currentUrl: new URL(location.pathname + location.search + location.hash, window.origin),\n        currentParams: ((_currentMatches$ = currentMatches[0]) === null || _currentMatches$ === void 0 ? void 0 : _currentMatches$.params) || {},\n        nextUrl: new URL(page, window.origin),\n        nextParams: match.params,\n        defaultShouldRevalidate: true\n      });\n      if (typeof routeChoice === \"boolean\") {\n        return routeChoice;\n      }\n    }\n    return true;\n  }) : nextMatches.filter((match, index) => {\n    let manifestRoute = manifest.routes[match.route.id];\n    return (mode === \"assets\" || manifestRoute.hasLoader) && (isNew(match, index) || matchPathChanged(match, index));\n  });\n  return newMatches;\n}\nfunction getDataLinkHrefs(page, matches, manifest) {\n  let path = parsePathPatch(page);\n  return dedupeHrefs(matches.filter(match => manifest.routes[match.route.id].hasLoader).map(match => {\n    let {\n      pathname,\n      search\n    } = path;\n    let searchParams = new URLSearchParams(search);\n    searchParams.set(\"_data\", match.route.id);\n    return `${pathname}?${searchParams}`;\n  }));\n}\nfunction getModuleLinkHrefs(matches, manifestPatch) {\n  return dedupeHrefs(matches.map(match => {\n    let route = manifestPatch.routes[match.route.id];\n    let hrefs = [route.module];\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n    return hrefs;\n  }).flat(1));\n}\n\n// The `<Script>` will render rel=modulepreload for the current page, we don't\n// need to include them in a page prefetch, this gives us the list to remove\n// while deduping.\nfunction getCurrentPageModulePreloadHrefs(matches, manifest) {\n  return dedupeHrefs(matches.map(match => {\n    let route = manifest.routes[match.route.id];\n    let hrefs = [route.module];\n    if (route.imports) {\n      hrefs = hrefs.concat(route.imports);\n    }\n    return hrefs;\n  }).flat(1));\n}\nfunction dedupeHrefs(hrefs) {\n  return [...new Set(hrefs)];\n}\nfunction sortKeys(obj) {\n  let sorted = {};\n  let keys = Object.keys(obj).sort();\n  for (let key of keys) {\n    sorted[key] = obj[key];\n  }\n  return sorted;\n}\nfunction dedupeLinkDescriptors(descriptors, preloads) {\n  let set = new Set();\n  let preloadsSet = new Set(preloads);\n  return descriptors.reduce((deduped, descriptor) => {\n    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === \"script\" && descriptor.href && preloadsSet.has(descriptor.href);\n    if (alreadyModulePreload) {\n      return deduped;\n    }\n    let key = JSON.stringify(sortKeys(descriptor));\n    if (!set.has(key)) {\n      set.add(key);\n      deduped.push({\n        key,\n        link: descriptor\n      });\n    }\n    return deduped;\n  }, []);\n}\n\n// https://github.com/remix-run/history/issues/897\nfunction parsePathPatch(href) {\n  let path = parsePath(href);\n  if (path.search === undefined) path.search = \"\";\n  return path;\n}\n\n// Detect if this browser supports <link rel=\"preload\"> (or has it enabled).\n// Originally added to handle the firefox `network.preload` config:\n//   https://bugzilla.mozilla.org/show_bug.cgi?id=1847811\nlet _isPreloadSupported;\nfunction isPreloadSupported() {\n  if (_isPreloadSupported !== undefined) {\n    return _isPreloadSupported;\n  }\n  let el = document.createElement(\"link\");\n  _isPreloadSupported = el.relList.supports(\"preload\");\n  el = null;\n  return _isPreloadSupported;\n}\n\nexport { getDataLinkHrefs, getKeyedLinksForMatches, getKeyedPrefetchLinks, getModuleLinkHrefs, getNewMatchesForLinks, isPageLinkDescriptor, prefetchStyleLinks };\n","/**\n * @remix-run/react v2.8.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\n// This escapeHtml utility is based on https://github.com/zertosh/htmlescape\n// License: https://github.com/zertosh/htmlescape/blob/0527ca7156a524d256101bb310a9f970f63078ad/LICENSE\n\n// We've chosen to inline the utility here to reduce the number of npm dependencies we have,\n// slightly decrease the code size compared the original package and make it esm compatible.\n\nconst ESCAPE_LOOKUP = {\n  \"&\": \"\\\\u0026\",\n  \">\": \"\\\\u003e\",\n  \"<\": \"\\\\u003c\",\n  \"\\u2028\": \"\\\\u2028\",\n  \"\\u2029\": \"\\\\u2029\"\n};\nconst ESCAPE_REGEX = /[&><\\u2028\\u2029]/g;\nfunction escapeHtml(html) {\n  return html.replace(ESCAPE_REGEX, match => ESCAPE_LOOKUP[match]);\n}\nfunction createHtml(html) {\n  return {\n    __html: html\n  };\n}\n\nexport { createHtml, escapeHtml };\n","/**\n * @remix-run/react v2.8.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { extends as _extends } from './_virtual/_rollupPluginBabelHelpers.js';\nimport * as React from 'react';\nimport { useHref, NavLink as NavLink$1, Link as Link$1, matchRoutes, useLocation, Await as Await$1, useNavigation, useAsyncError, useMatches as useMatches$1, useLoaderData as useLoaderData$1, useRouteLoaderData as useRouteLoaderData$1, useActionData as useActionData$1, useFetcher as useFetcher$1, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext } from 'react-router-dom';\nimport invariant from './invariant.js';\nimport { getKeyedLinksForMatches, isPageLinkDescriptor, getNewMatchesForLinks, getDataLinkHrefs, getModuleLinkHrefs, getKeyedPrefetchLinks } from './links.js';\nimport { escapeHtml, createHtml } from './markup.js';\n\nfunction useDataRouterContext() {\n  let context = React.useContext(UNSAFE_DataRouterContext);\n  invariant(context, \"You must render this element inside a <DataRouterContext.Provider> element\");\n  return context;\n}\nfunction useDataRouterStateContext() {\n  let context = React.useContext(UNSAFE_DataRouterStateContext);\n  invariant(context, \"You must render this element inside a <DataRouterStateContext.Provider> element\");\n  return context;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// RemixContext\n\nconst RemixContext = /*#__PURE__*/React.createContext(undefined);\nRemixContext.displayName = \"Remix\";\nfunction useRemixContext() {\n  let context = React.useContext(RemixContext);\n  invariant(context, \"You must render this element inside a <Remix> element\");\n  return context;\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Public API\n\n/**\n * Defines the prefetching behavior of the link:\n *\n * - \"none\": Never fetched\n * - \"intent\": Fetched when the user focuses or hovers the link\n * - \"render\": Fetched when the link is rendered\n * - \"viewport\": Fetched when the link is in the viewport\n */\n\nfunction usePrefetchBehavior(prefetch, theirElementProps) {\n  let [maybePrefetch, setMaybePrefetch] = React.useState(false);\n  let [shouldPrefetch, setShouldPrefetch] = React.useState(false);\n  let {\n    onFocus,\n    onBlur,\n    onMouseEnter,\n    onMouseLeave,\n    onTouchStart\n  } = theirElementProps;\n  let ref = React.useRef(null);\n  React.useEffect(() => {\n    if (prefetch === \"render\") {\n      setShouldPrefetch(true);\n    }\n    if (prefetch === \"viewport\") {\n      let callback = entries => {\n        entries.forEach(entry => {\n          setShouldPrefetch(entry.isIntersecting);\n        });\n      };\n      let observer = new IntersectionObserver(callback, {\n        threshold: 0.5\n      });\n      if (ref.current) observer.observe(ref.current);\n      return () => {\n        observer.disconnect();\n      };\n    }\n  }, [prefetch]);\n  let setIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(true);\n    }\n  };\n  let cancelIntent = () => {\n    if (prefetch === \"intent\") {\n      setMaybePrefetch(false);\n      setShouldPrefetch(false);\n    }\n  };\n  React.useEffect(() => {\n    if (maybePrefetch) {\n      let id = setTimeout(() => {\n        setShouldPrefetch(true);\n      }, 100);\n      return () => {\n        clearTimeout(id);\n      };\n    }\n  }, [maybePrefetch]);\n  return [shouldPrefetch, ref, {\n    onFocus: composeEventHandlers(onFocus, setIntent),\n    onBlur: composeEventHandlers(onBlur, cancelIntent),\n    onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),\n    onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),\n    onTouchStart: composeEventHandlers(onTouchStart, setIntent)\n  }];\n}\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n\n/**\n * A special kind of `<Link>` that knows whether it is \"active\".\n *\n * @see https://remix.run/components/nav-link\n */\nlet NavLink = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to);\n  let href = useHref(to);\n  let [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(NavLink$1, _extends({}, props, prefetchHandlers, {\n    ref: mergeRefs(forwardedRef, ref),\n    to: to\n  })), shouldPrefetch && !isAbsolute ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nNavLink.displayName = \"NavLink\";\n\n/**\n * This component renders an anchor tag and is the primary way the user will\n * navigate around your website.\n *\n * @see https://remix.run/components/link\n */\nlet Link = /*#__PURE__*/React.forwardRef(({\n  to,\n  prefetch = \"none\",\n  ...props\n}, forwardedRef) => {\n  let isAbsolute = typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to);\n  let href = useHref(to);\n  let [shouldPrefetch, ref, prefetchHandlers] = usePrefetchBehavior(prefetch, props);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Link$1, _extends({}, props, prefetchHandlers, {\n    ref: mergeRefs(forwardedRef, ref),\n    to: to\n  })), shouldPrefetch && !isAbsolute ? /*#__PURE__*/React.createElement(PrefetchPageLinks, {\n    page: href\n  }) : null);\n});\nLink.displayName = \"Link\";\nfunction composeEventHandlers(theirHandler, ourHandler) {\n  return event => {\n    theirHandler && theirHandler(event);\n    if (!event.defaultPrevented) {\n      ourHandler(event);\n    }\n  };\n}\n\n// Return the matches actively being displayed:\n// - In SPA Mode we only SSR/hydrate the root match, and include all matches\n//   after hydration. This lets the router handle initial match loads via lazy().\n// - When an error boundary is rendered, we slice off matches up to the\n//   boundary for <Links>/<Meta>\nfunction getActiveMatches(matches, errors, isSpaMode) {\n  if (isSpaMode && !isHydrated) {\n    return [matches[0]];\n  }\n  if (errors) {\n    let errorIdx = matches.findIndex(m => errors[m.route.id]);\n    return matches.slice(0, errorIdx + 1);\n  }\n  return matches;\n}\n\n/**\n * Renders the `<link>` tags for the current routes.\n *\n * @see https://remix.run/components/links\n */\nfunction Links() {\n  let {\n    isSpaMode,\n    manifest,\n    routeModules,\n    criticalCss\n  } = useRemixContext();\n  let {\n    errors,\n    matches: routerMatches\n  } = useDataRouterStateContext();\n  let matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let keyedLinks = React.useMemo(() => getKeyedLinksForMatches(matches, routeModules, manifest), [matches, routeModules, manifest]);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, criticalCss ? /*#__PURE__*/React.createElement(\"style\", {\n    dangerouslySetInnerHTML: {\n      __html: criticalCss\n    }\n  }) : null, keyedLinks.map(({\n    key,\n    link\n  }) => isPageLinkDescriptor(link) ? /*#__PURE__*/React.createElement(PrefetchPageLinks, _extends({\n    key: key\n  }, link)) : /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: key\n  }, link))));\n}\n\n/**\n * This component renders all the `<link rel=\"prefetch\">` and\n * `<link rel=\"modulepreload\"/>` tags for all the assets (data, modules, css) of\n * a given page.\n *\n * @param props\n * @param props.page\n * @see https://remix.run/components/prefetch-page-links\n */\nfunction PrefetchPageLinks({\n  page,\n  ...dataLinkProps\n}) {\n  let {\n    router\n  } = useDataRouterContext();\n  let matches = React.useMemo(() => matchRoutes(router.routes, page, router.basename), [router.routes, page, router.basename]);\n  if (!matches) {\n    console.warn(`Tried to prefetch ${page} but no routes matched.`);\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(PrefetchPageLinksImpl, _extends({\n    page: page,\n    matches: matches\n  }, dataLinkProps));\n}\nfunction useKeyedPrefetchLinks(matches) {\n  let {\n    manifest,\n    routeModules\n  } = useRemixContext();\n  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React.useState([]);\n  React.useEffect(() => {\n    let interrupted = false;\n    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(links => {\n      if (!interrupted) {\n        setKeyedPrefetchLinks(links);\n      }\n    });\n    return () => {\n      interrupted = true;\n    };\n  }, [matches, manifest, routeModules]);\n  return keyedPrefetchLinks;\n}\nfunction PrefetchPageLinksImpl({\n  page,\n  matches: nextMatches,\n  ...linkProps\n}) {\n  let location = useLocation();\n  let {\n    manifest\n  } = useRemixContext();\n  let {\n    matches\n  } = useDataRouterStateContext();\n  let newMatchesForData = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"data\"), [page, nextMatches, matches, manifest, location]);\n  let newMatchesForAssets = React.useMemo(() => getNewMatchesForLinks(page, nextMatches, matches, manifest, location, \"assets\"), [page, nextMatches, matches, manifest, location]);\n  let dataHrefs = React.useMemo(() => getDataLinkHrefs(page, newMatchesForData, manifest), [newMatchesForData, page, manifest]);\n  let moduleHrefs = React.useMemo(() => getModuleLinkHrefs(newMatchesForAssets, manifest), [newMatchesForAssets, manifest]);\n\n  // needs to be a hook with async behavior because we need the modules, not\n  // just the manifest like the other links in here.\n  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, dataHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: href,\n    rel: \"prefetch\",\n    as: \"fetch\",\n    href: href\n  }, linkProps))), moduleHrefs.map(href => /*#__PURE__*/React.createElement(\"link\", _extends({\n    key: href,\n    rel: \"modulepreload\",\n    href: href\n  }, linkProps))), keyedPrefetchLinks.map(({\n    key,\n    link\n  }) =>\n  /*#__PURE__*/\n  // these don't spread `linkProps` because they are full link descriptors\n  // already with their own props\n  React.createElement(\"link\", _extends({\n    key: key\n  }, link))));\n}\n\n/**\n * Renders HTML tags related to metadata for the current route.\n *\n * @see https://remix.run/components/meta\n */\nfunction Meta() {\n  let {\n    isSpaMode,\n    routeModules\n  } = useRemixContext();\n  let {\n    errors,\n    matches: routerMatches,\n    loaderData\n  } = useDataRouterStateContext();\n  let location = useLocation();\n  let _matches = getActiveMatches(routerMatches, errors, isSpaMode);\n  let error = null;\n  if (errors) {\n    error = errors[_matches[_matches.length - 1].route.id];\n  }\n  let meta = [];\n  let leafMeta = null;\n  let matches = [];\n  for (let i = 0; i < _matches.length; i++) {\n    let _match = _matches[i];\n    let routeId = _match.route.id;\n    let data = loaderData[routeId];\n    let params = _match.params;\n    let routeModule = routeModules[routeId];\n    let routeMeta = [];\n    let match = {\n      id: routeId,\n      data,\n      meta: [],\n      params: _match.params,\n      pathname: _match.pathname,\n      handle: _match.route.handle,\n      error\n    };\n    matches[i] = match;\n    if (routeModule !== null && routeModule !== void 0 && routeModule.meta) {\n      routeMeta = typeof routeModule.meta === \"function\" ? routeModule.meta({\n        data,\n        params,\n        location,\n        matches,\n        error\n      }) : Array.isArray(routeModule.meta) ? [...routeModule.meta] : routeModule.meta;\n    } else if (leafMeta) {\n      // We only assign the route's meta to the nearest leaf if there is no meta\n      // export in the route. The meta function may return a falsy value which\n      // is effectively the same as an empty array.\n      routeMeta = [...leafMeta];\n    }\n    routeMeta = routeMeta || [];\n    if (!Array.isArray(routeMeta)) {\n      throw new Error(\"The route at \" + _match.route.path + \" returns an invalid value. All route meta functions must \" + \"return an array of meta objects.\" + \"\\n\\nTo reference the meta function API, see https://remix.run/route/meta\");\n    }\n    match.meta = routeMeta;\n    matches[i] = match;\n    meta = [...routeMeta];\n    leafMeta = meta;\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, meta.flat().map(metaProps => {\n    if (!metaProps) {\n      return null;\n    }\n    if (\"tagName\" in metaProps) {\n      let {\n        tagName,\n        ...rest\n      } = metaProps;\n      if (!isValidMetaTag(tagName)) {\n        console.warn(`A meta object uses an invalid tagName: ${tagName}. Expected either 'link' or 'meta'`);\n        return null;\n      }\n      let Comp = tagName;\n      return /*#__PURE__*/React.createElement(Comp, _extends({\n        key: JSON.stringify(rest)\n      }, rest));\n    }\n    if (\"title\" in metaProps) {\n      return /*#__PURE__*/React.createElement(\"title\", {\n        key: \"title\"\n      }, String(metaProps.title));\n    }\n    if (\"charset\" in metaProps) {\n      metaProps.charSet ??= metaProps.charset;\n      delete metaProps.charset;\n    }\n    if (\"charSet\" in metaProps && metaProps.charSet != null) {\n      return typeof metaProps.charSet === \"string\" ? /*#__PURE__*/React.createElement(\"meta\", {\n        key: \"charSet\",\n        charSet: metaProps.charSet\n      }) : null;\n    }\n    if (\"script:ld+json\" in metaProps) {\n      try {\n        let json = JSON.stringify(metaProps[\"script:ld+json\"]);\n        return /*#__PURE__*/React.createElement(\"script\", {\n          key: `script:ld+json:${json}`,\n          type: \"application/ld+json\",\n          dangerouslySetInnerHTML: {\n            __html: json\n          }\n        });\n      } catch (err) {\n        return null;\n      }\n    }\n    return /*#__PURE__*/React.createElement(\"meta\", _extends({\n      key: JSON.stringify(metaProps)\n    }, metaProps));\n  }));\n}\nfunction isValidMetaTag(tagName) {\n  return typeof tagName === \"string\" && /^(meta|link)$/.test(tagName);\n}\nfunction Await(props) {\n  return /*#__PURE__*/React.createElement(Await$1, props);\n}\n\n/**\n * Tracks whether Remix has finished hydrating or not, so scripts can be skipped\n * during client-side updates.\n */\nlet isHydrated = false;\n/**\n * Renders the `<script>` tags needed for the initial render. Bundles for\n * additional routes are loaded later as needed.\n *\n * @param props Additional properties to add to each script tag that is rendered.\n * In addition to scripts, \\<link rel=\"modulepreload\"> tags receive the crossOrigin\n * property if provided.\n *\n * @see https://remix.run/components/scripts\n */\nfunction Scripts(props) {\n  let {\n    manifest,\n    serverHandoffString,\n    abortDelay,\n    serializeError,\n    isSpaMode\n  } = useRemixContext();\n  let {\n    router,\n    static: isStatic,\n    staticContext\n  } = useDataRouterContext();\n  let {\n    matches: routerMatches\n  } = useDataRouterStateContext();\n  let navigation = useNavigation();\n  let matches = getActiveMatches(routerMatches, null, isSpaMode);\n  React.useEffect(() => {\n    isHydrated = true;\n  }, []);\n  let serializePreResolvedErrorImp = (key, error) => {\n    let toSerialize;\n    if (serializeError && error instanceof Error) {\n      toSerialize = serializeError(error);\n    } else {\n      toSerialize = error;\n    }\n    return `${JSON.stringify(key)}:__remixContext.p(!1, ${escapeHtml(JSON.stringify(toSerialize))})`;\n  };\n  let serializePreresolvedDataImp = (routeId, key, data) => {\n    let serializedData;\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return serializePreResolvedErrorImp(key, error);\n    }\n    return `${JSON.stringify(key)}:__remixContext.p(${escapeHtml(serializedData)})`;\n  };\n  let serializeErrorImp = (routeId, key, error) => {\n    let toSerialize;\n    if (serializeError && error instanceof Error) {\n      toSerialize = serializeError(error);\n    } else {\n      toSerialize = error;\n    }\n    return `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, !1, ${escapeHtml(JSON.stringify(toSerialize))})`;\n  };\n  let serializeDataImp = (routeId, key, data) => {\n    let serializedData;\n    try {\n      serializedData = JSON.stringify(data);\n    } catch (error) {\n      return serializeErrorImp(routeId, key, error);\n    }\n    return `__remixContext.r(${JSON.stringify(routeId)}, ${JSON.stringify(key)}, ${escapeHtml(serializedData)})`;\n  };\n  let deferredScripts = [];\n  let initialScripts = React.useMemo(() => {\n    var _manifest$hmr;\n    let contextScript = staticContext ? `window.__remixContext = ${serverHandoffString};` : \" \";\n    let activeDeferreds = staticContext === null || staticContext === void 0 ? void 0 : staticContext.activeDeferreds;\n    // This sets up the __remixContext with utility functions used by the\n    // deferred scripts.\n    // - __remixContext.p is a function that takes a resolved value or error and returns a promise.\n    //   This is used for transmitting pre-resolved promises from the server to the client.\n    // - __remixContext.n is a function that takes a routeID and key to returns a promise for later\n    //   resolution by the subsequently streamed chunks.\n    // - __remixContext.r is a function that takes a routeID, key and value or error and resolves\n    //   the promise created by __remixContext.n.\n    // - __remixContext.t is a map or routeId to keys to an object containing `e` and `r` methods\n    //   to resolve or reject the promise created by __remixContext.n.\n    // - __remixContext.a is the active number of deferred scripts that should be rendered to match\n    //   the SSR tree for hydration on the client.\n    contextScript += !activeDeferreds ? \"\" : [\"__remixContext.p = function(v,e,p,x) {\", \"  if (typeof e !== 'undefined') {\", process.env.NODE_ENV === \"development\" ? \"    x=new Error(e.message);\\n    x.stack=e.stack;\" : '    x=new Error(\"Unexpected Server Error\");\\n    x.stack=undefined;', \"    p=Promise.reject(x);\", \"  } else {\", \"    p=Promise.resolve(v);\", \"  }\", \"  return p;\", \"};\", \"__remixContext.n = function(i,k) {\", \"  __remixContext.t = __remixContext.t || {};\", \"  __remixContext.t[i] = __remixContext.t[i] || {};\", \"  let p = new Promise((r, e) => {__remixContext.t[i][k] = {r:(v)=>{r(v);},e:(v)=>{e(v);}};});\", typeof abortDelay === \"number\" ? `setTimeout(() => {if(typeof p._error !== \"undefined\" || typeof p._data !== \"undefined\"){return;} __remixContext.t[i][k].e(new Error(\"Server timeout.\"))}, ${abortDelay});` : \"\", \"  return p;\", \"};\", \"__remixContext.r = function(i,k,v,e,p,x) {\", \"  p = __remixContext.t[i][k];\", \"  if (typeof e !== 'undefined') {\", process.env.NODE_ENV === \"development\" ? \"    x=new Error(e.message);\\n    x.stack=e.stack;\" : '    x=new Error(\"Unexpected Server Error\");\\n    x.stack=undefined;', \"    p.e(x);\", \"  } else {\", \"    p.r(v);\", \"  }\", \"};\"].join(\"\\n\") + Object.entries(activeDeferreds).map(([routeId, deferredData]) => {\n      let pendingKeys = new Set(deferredData.pendingKeys);\n      let promiseKeyValues = deferredData.deferredKeys.map(key => {\n        if (pendingKeys.has(key)) {\n          deferredScripts.push( /*#__PURE__*/React.createElement(DeferredHydrationScript, {\n            key: `${routeId} | ${key}`,\n            deferredData: deferredData,\n            routeId: routeId,\n            dataKey: key,\n            scriptProps: props,\n            serializeData: serializeDataImp,\n            serializeError: serializeErrorImp\n          }));\n          return `${JSON.stringify(key)}:__remixContext.n(${JSON.stringify(routeId)}, ${JSON.stringify(key)})`;\n        } else {\n          let trackedPromise = deferredData.data[key];\n          if (typeof trackedPromise._error !== \"undefined\") {\n            return serializePreResolvedErrorImp(key, trackedPromise._error);\n          } else {\n            return serializePreresolvedDataImp(routeId, key, trackedPromise._data);\n          }\n        }\n      }).join(\",\\n\");\n      return `Object.assign(__remixContext.state.loaderData[${JSON.stringify(routeId)}], {${promiseKeyValues}});`;\n    }).join(\"\\n\") + (deferredScripts.length > 0 ? `__remixContext.a=${deferredScripts.length};` : \"\");\n    let routeModulesScript = !isStatic ? \" \" : `${(_manifest$hmr = manifest.hmr) !== null && _manifest$hmr !== void 0 && _manifest$hmr.runtime ? `import ${JSON.stringify(manifest.hmr.runtime)};` : \"\"}import ${JSON.stringify(manifest.url)};\n${matches.map((match, index) => `import * as route${index} from ${JSON.stringify(manifest.routes[match.route.id].module)};`).join(\"\\n\")}\nwindow.__remixRouteModules = {${matches.map((match, index) => `${JSON.stringify(match.route.id)}:route${index}`).join(\",\")}};\n\nimport(${JSON.stringify(manifest.entry.module)});`;\n    return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: createHtml(contextScript),\n      type: undefined\n    })), /*#__PURE__*/React.createElement(\"script\", _extends({}, props, {\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: createHtml(routeModulesScript),\n      type: \"module\",\n      async: true\n    })));\n    // disabled deps array because we are purposefully only rendering this once\n    // for hydration, after that we want to just continue rendering the initial\n    // scripts as they were when the page first loaded\n    // eslint-disable-next-line\n  }, []);\n  if (!isStatic && typeof __remixContext === \"object\" && __remixContext.a) {\n    for (let i = 0; i < __remixContext.a; i++) {\n      deferredScripts.push( /*#__PURE__*/React.createElement(DeferredHydrationScript, {\n        key: i,\n        scriptProps: props,\n        serializeData: serializeDataImp,\n        serializeError: serializeErrorImp\n      }));\n    }\n  }\n\n  // avoid waterfall when importing the next route module\n  let nextMatches = React.useMemo(() => {\n    if (navigation.location) {\n      // FIXME: can probably use transitionManager `nextMatches`\n      let matches = matchRoutes(router.routes, navigation.location, router.basename);\n      invariant(matches, `No routes match path \"${navigation.location.pathname}\"`);\n      return matches;\n    }\n    return [];\n  }, [navigation.location, router.routes, router.basename]);\n  let routePreloads = matches.concat(nextMatches).map(match => {\n    let route = manifest.routes[match.route.id];\n    return (route.imports || []).concat([route.module]);\n  }).flat(1);\n  let preloads = isHydrated ? [] : manifest.entry.imports.concat(routePreloads);\n  return isHydrated ? null : /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"link\", {\n    rel: \"modulepreload\",\n    href: manifest.url,\n    crossOrigin: props.crossOrigin\n  }), /*#__PURE__*/React.createElement(\"link\", {\n    rel: \"modulepreload\",\n    href: manifest.entry.module,\n    crossOrigin: props.crossOrigin\n  }), dedupe(preloads).map(path => /*#__PURE__*/React.createElement(\"link\", {\n    key: path,\n    rel: \"modulepreload\",\n    href: path,\n    crossOrigin: props.crossOrigin\n  })), initialScripts, deferredScripts);\n}\nfunction DeferredHydrationScript({\n  dataKey,\n  deferredData,\n  routeId,\n  scriptProps,\n  serializeData,\n  serializeError\n}) {\n  if (typeof document === \"undefined\" && deferredData && dataKey && routeId) {\n    invariant(deferredData.pendingKeys.includes(dataKey), `Deferred data for route ${routeId} with key ${dataKey} was not pending but tried to render a script for it.`);\n  }\n  return /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback:\n    // This makes absolutely no sense. The server renders null as a fallback,\n    // but when hydrating, we need to render a script tag to avoid a hydration issue.\n    // To reproduce a hydration mismatch, just render null as a fallback.\n    typeof document === \"undefined\" && deferredData && dataKey && routeId ? null : /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n      async: true,\n      suppressHydrationWarning: true,\n      dangerouslySetInnerHTML: {\n        __html: \" \"\n      }\n    }))\n  }, typeof document === \"undefined\" && deferredData && dataKey && routeId ? /*#__PURE__*/React.createElement(Await, {\n    resolve: deferredData.data[dataKey],\n    errorElement: /*#__PURE__*/React.createElement(ErrorDeferredHydrationScript, {\n      dataKey: dataKey,\n      routeId: routeId,\n      scriptProps: scriptProps,\n      serializeError: serializeError\n    }),\n    children: data => {\n      return /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n        async: true,\n        suppressHydrationWarning: true,\n        dangerouslySetInnerHTML: {\n          __html: serializeData(routeId, dataKey, data)\n        }\n      }));\n    }\n  }) : /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n    async: true,\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: \" \"\n    }\n  })));\n}\nfunction ErrorDeferredHydrationScript({\n  dataKey,\n  routeId,\n  scriptProps,\n  serializeError\n}) {\n  let error = useAsyncError();\n  return /*#__PURE__*/React.createElement(\"script\", _extends({}, scriptProps, {\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: serializeError(routeId, dataKey, error)\n    }\n  }));\n}\nfunction dedupe(array) {\n  return [...new Set(array)];\n}\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n *\n * @see https://remix.run/hooks/use-matches\n */\nfunction useMatches() {\n  return useMatches$1();\n}\n\n/**\n * Returns the JSON parsed data from the current route's `loader`.\n *\n * @see https://remix.run/hooks/use-loader-data\n */\nfunction useLoaderData() {\n  return useLoaderData$1();\n}\n\n/**\n * Returns the loaderData for the given routeId.\n *\n * @see https://remix.run/hooks/use-route-loader-data\n */\nfunction useRouteLoaderData(routeId) {\n  return useRouteLoaderData$1(routeId);\n}\n\n/**\n * Returns the JSON parsed data from the current route's `action`.\n *\n * @see https://remix.run/hooks/use-action-data\n */\nfunction useActionData() {\n  return useActionData$1();\n}\n\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n *\n * @see https://remix.run/hooks/use-fetcher\n */\nfunction useFetcher(opts = {}) {\n  return useFetcher$1(opts);\n}\n\n/**\n * This component connects your app to the Remix asset server and\n * automatically reloads the page when files change in development.\n * In production, it renders null, so you can safely render it always in your root route.\n *\n * @see https://remix.run/docs/components/live-reload\n */\nconst LiveReload =\n// Dead Code Elimination magic for production builds.\n// This way devs don't have to worry about doing the NODE_ENV check themselves.\nprocess.env.NODE_ENV !== \"development\" ? () => null : function LiveReload({\n  origin,\n  port,\n  timeoutMs = 1000,\n  nonce = undefined\n}) {\n  // @ts-expect-error\n  let isViteClient = import.meta && import.meta.env !== undefined;\n  if (isViteClient) {\n    console.warn([\"`<LiveReload />` is obsolete when using Vite and can conflict with Vite's built-in HMR runtime.\", \"\", \"Remove `<LiveReload />` from your code and instead only use `<Scripts />`.\", \"Then refresh the page to remove lingering scripts from `<LiveReload />`.\"].join(\"\\n\"));\n    return null;\n  }\n  origin ??= process.env.REMIX_DEV_ORIGIN;\n  let js = String.raw;\n  return /*#__PURE__*/React.createElement(\"script\", {\n    nonce: nonce,\n    suppressHydrationWarning: true,\n    dangerouslySetInnerHTML: {\n      __html: js`\n                function remixLiveReloadConnect(config) {\n                  let LIVE_RELOAD_ORIGIN = ${JSON.stringify(origin)};\n                  let protocol =\n                    LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).protocol.replace(/^http/, \"ws\") :\n                    location.protocol === \"https:\" ? \"wss:\" : \"ws:\"; // remove in v2?\n                  let hostname = LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).hostname : location.hostname;\n                  let url = new URL(protocol + \"//\" + hostname + \"/socket\");\n\n                  url.port =\n                    ${port} ||\n                    (LIVE_RELOAD_ORIGIN ? new URL(LIVE_RELOAD_ORIGIN).port : 8002);\n\n                  let ws = new WebSocket(url.href);\n                  ws.onmessage = async (message) => {\n                    let event = JSON.parse(message.data);\n                    if (event.type === \"LOG\") {\n                      console.log(event.message);\n                    }\n                    if (event.type === \"RELOAD\") {\n                      console.log(\"💿 Reloading window ...\");\n                      window.location.reload();\n                    }\n                    if (event.type === \"HMR\") {\n                      if (!window.__hmr__ || !window.__hmr__.contexts) {\n                        console.log(\"💿 [HMR] No HMR context, reloading window ...\");\n                        window.location.reload();\n                        return;\n                      }\n                      if (!event.updates || !event.updates.length) return;\n                      let updateAccepted = false;\n                      let needsRevalidation = new Set();\n                      for (let update of event.updates) {\n                        console.log(\"[HMR] \" + update.reason + \" [\" + update.id +\"]\")\n                        if (update.revalidate) {\n                          needsRevalidation.add(update.routeId);\n                          console.log(\"[HMR] Revalidating [\" + update.routeId + \"]\");\n                        }\n                        let imported = await import(update.url +  '?t=' + event.assetsManifest.hmr.timestamp);\n                        if (window.__hmr__.contexts[update.id]) {\n                          let accepted = window.__hmr__.contexts[update.id].emit(\n                            imported\n                          );\n                          if (accepted) {\n                            console.log(\"[HMR] Update accepted by\", update.id);\n                            updateAccepted = true;\n                          }\n                        }\n                      }\n                      if (event.assetsManifest && window.__hmr__.contexts[\"remix:manifest\"]) {\n                        let accepted = window.__hmr__.contexts[\"remix:manifest\"].emit(\n                          { needsRevalidation, assetsManifest: event.assetsManifest }\n                        );\n                        if (accepted) {\n                          console.log(\"[HMR] Update accepted by\", \"remix:manifest\");\n                          updateAccepted = true;\n                        }\n                      }\n                      if (!updateAccepted) {\n                        console.log(\"[HMR] Update rejected, reloading...\");\n                        window.location.reload();\n                      }\n                    }\n                  };\n                  ws.onopen = () => {\n                    if (config && typeof config.onOpen === \"function\") {\n                      config.onOpen();\n                    }\n                  };\n                  ws.onclose = (event) => {\n                    if (event.code === 1006) {\n                      console.log(\"Remix dev asset server web socket closed. Reconnecting...\");\n                      setTimeout(\n                        () =>\n                          remixLiveReloadConnect({\n                            onOpen: () => window.location.reload(),\n                          }),\n                      ${String(timeoutMs)}\n                      );\n                    }\n                  };\n                  ws.onerror = (error) => {\n                    console.log(\"Remix dev asset server web socket error:\");\n                    console.error(error);\n                  };\n                }\n                remixLiveReloadConnect();\n              `\n    }\n  });\n};\nfunction mergeRefs(...refs) {\n  return value => {\n    refs.forEach(ref => {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\nexport { Await, Link, Links, LiveReload, Meta, NavLink, PrefetchPageLinks, RemixContext, Scripts, composeEventHandlers, useActionData, useFetcher, useLoaderData, useMatches, useRemixContext, useRouteLoaderData };\n"],"file":"assets/components-_HPsJqfq.js"}